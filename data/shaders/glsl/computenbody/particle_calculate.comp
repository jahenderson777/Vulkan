
#version 450

struct Particle
{
	vec4 pos;
	vec4 vel;
};

// Binding 0 : Position storage buffer
layout(std140, binding = 0) buffer Pos 
{
   Particle particles[ ];
};

layout (local_size_x = 256) in;

layout (binding = 1) uniform UBO 
{
	float deltaT;
	int particleCount;
} ubo;

layout (constant_id = 0) const int SHARED_DATA_SIZE = 1;
layout (constant_id = 1) const float GRAVITY = 0.002;
layout (constant_id = 2) const float POWER = 0.75;
layout (constant_id = 3) const float SOFTEN = 0.0075;

// Share data between computer shader invocations to speed up caluclations
//shared vec4 sharedData[SHARED_DATA_SIZE];

void main() 
{
	// Current SSBO index
	uint index = gl_GlobalInvocationID.x;
	if (index >= ubo.particleCount) 
		return;	

    uint darkLightSplit = ubo.particleCount / 26;
    bool indexIsDark = index > darkLightSplit;
    
	vec3 position = particles[index].pos.xyz;
	//vec4 velocity = particles[index].vel;
	//vec4 acceleration = vec4(0.0);
    vec3 d = vec3(0.0, 0.0, 0.0);
    vec3 c = (d - position) / 25.0;
    
	for (int i = 0; i < ubo.particleCount; i ++)
	{
        bool iIsDark = i > darkLightSplit;
        vec3 delta = particles[i].pos.xyz - position;
        float targetDistance = 1000.0 * length(delta); //sqrt(dot(delta, delta));
        if (targetDistance > 18.0)
        {
            float scale = 1.0;
            if (!indexIsDark)
            {
                scale = 1.0;
            }
            if (!indexIsDark && !iIsDark && targetDistance > 400.0)
            {
                scale = 0.0;
            }
        
            d += delta * scale * 60000.0 / pow(targetDistance, 3.0);//;//delta * (0.002 / (targetDistance * targetDistance * targetDistance * targetDistance)) * 0.00000035;
        }
	}
    
    if (indexIsDark)
    {
        particles[index].pos.xyz -= d - c*c*c;
        particles[index].vel.w = 0.1;
    }
    else
    {
        particles[index].pos.xyz += (d/4.0);
        particles[index].vel.w = 0.9;
    }
	/*particles[index].vel.xyz += ubo.deltaT * acceleration.xyz;

	// Gradient texture position
	particles[index].vel.w += 0.1 * ubo.deltaT;
	if (particles[index].vel.w > 1.0)
		particles[index].vel.w -= 1.0;*/
}
