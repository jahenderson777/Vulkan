
#version 450

struct Particle
{
	vec4 pos;
	vec4 vel;
};

// Binding 0 : Position storage buffer
layout(std140, binding = 0) buffer Pos 
{
   Particle particles[ ];
};

layout (local_size_x = 256) in;

layout (binding = 1) uniform UBO 
{
	float deltaT;
	int particleCount;
} ubo;

/*layout (constant_id = 0) const int SHARED_DATA_SIZE = 1;
layout (constant_id = 1) const float GRAVITY = 0.002;
layout (constant_id = 2) const float POWER = 0.75;
layout (constant_id = 3) const float SOFTEN = 0.0075;*/

// Share data between computer shader invocations to speed up caluclations
//shared vec4 sharedData[SHARED_DATA_SIZE];

#define QUATERNION_IDENTITY vec4(0, 0, 0, 1)

// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl
vec4 q_slerp(vec4 a, vec4 b, float t) {
    // if either input is zero, return the other.
    if (length(a) == 0.0) {
        if (length(b) == 0.0) {
            return QUATERNION_IDENTITY;
        }
        return b;
    } else if (length(b) == 0.0) {
        return a;
    }

    float cosHalfAngle = a.w * b.w + dot(a.xyz, b.xyz);

    if (cosHalfAngle >= 1.0 || cosHalfAngle <= -1.0) {
        return a;
    } else if (cosHalfAngle < 0.0) {
        b.xyz = -b.xyz;
        b.w = -b.w;
        cosHalfAngle = -cosHalfAngle;
    }

    float blendA;
    float blendB;
    if (cosHalfAngle < 0.99) {
        // do proper slerp for big angles
        float halfAngle = acos(cosHalfAngle);
        float sinHalfAngle = sin(halfAngle);
        float oneOverSinHalfAngle = 1.0 / sinHalfAngle;
        blendA = sin(halfAngle * (1.0 - t)) * oneOverSinHalfAngle;
        blendB = sin(halfAngle * t) * oneOverSinHalfAngle;
    } else {
        // do lerp if angle is really small.
        blendA = 1.0 - t;
        blendB = t;
    }

    vec4 result = vec4(blendA * a.xyz + blendB * b.xyz, blendA * a.w + blendB * b.w);
    if (length(result) > 0.0) {
        return normalize(result);
    }
    return QUATERNION_IDENTITY;
}

void main() 
{
	// Current SSBO index
	uint index = gl_GlobalInvocationID.x;
	if (index >= ubo.particleCount) 
		return;	

    uint darkLightSplit = ubo.particleCount / 26;
    bool indexIsDark = index > darkLightSplit;
    
	vec3 position = particles[index].pos.xyz;
	//vec4 velocity = particles[index].vel;
	//vec4 acceleration = vec4(0.0);
    vec3 totalDeltaPos = vec3(0.0);
    vec4 totalDeltaOrient = vec4(0.0);
    vec3 c = (vec3(0.0) - position) / 25.0;
    
	for (int i = 0; i < ubo.particleCount; i ++)
	{
        bool iIsDark = i > darkLightSplit;
        vec3 deltaPos = particles[i].pos.xyz - position;
        float targetDistance = 1000.0 * length(deltaPos); //sqrt(dot(delta, delta));
        if (targetDistance > 18.0)
        {
            float scale = 1.0;
            if (!indexIsDark)
            {
                scale = 1.0;
            }
            if (!indexIsDark && !iIsDark && targetDistance > 1400.0)
            {
                scale = 0.0;
            }
            scale *= 60000.0 / pow(targetDistance, 3.0);
            totalDeltaPos += deltaPos * scale;
        }
	}
    
    if (indexIsDark)
    {
        particles[index].pos.xyz -= totalDeltaPos - c*c*c;
        particles[index].pos.w = 0.1;
    }
    else
    {
        particles[index].pos.xyz += (totalDeltaPos/4.0);
        particles[index].pos.w = 0.9;
    }
	/*particles[index].vel.xyz += ubo.deltaT * acceleration.xyz;

	// Gradient texture position
	particles[index].vel.w += 0.1 * ubo.deltaT;
	if (particles[index].vel.w > 1.0)
		particles[index].vel.w -= 1.0;*/
}
